#!/usr/bin/env python

# Dump protobuf descriptors from binary images of the MAIN modem app for Samsung
# modems used by Google Pixel devices. The code in those binary images uses nanopb
# for handling protobuf, and the descriptors store some type information for
# decoding the messages, which is also useful for almost fully reconstructing the
# original protobuf specification files. However, some information, such as enums
# and the actual type and signness of fixed-size types, is unfortunately lost.
# These can only be recovered by reverse engineering the code that uses the decoded
# data.

# NOTE: This code only works with descriptors generated by nanopb versions in the
# range 0.2.5 to 0.3.9.3 (0.3.9.4 added an explicit bool type and broke compatiblity
# by adding it to the beginning of the types "enum", and 0.4.0 completely changed
# the format of the descriptor). Make sure that the binary you're analysing uses
# a nanopb version that is supported by this script by manually inspecting the
# generated output.

from __future__ import print_function
import enum  # Requires enum34 on Python 2
import io
import os
import struct


class NanoDesc(object):
    _FMT = struct.Struct(
        '<I'  # Tag
        'B'  # Type
        'I'  # Data offset
        'i'  # Size offset
        'I'  # Data size
        'I'  # Array size
        'I'  # Ptr (for sub-messages, extensions, and default values)
        )
    SIZE = _FMT.size

    # Needed for cleanly checking if we got an empty descriptor on Python 2
    ZERO = b''.join(b'\x00' for _ in range(SIZE))

    class Type(enum.IntEnum):
        VarInt = 0
        UVarInt = 1
        SVarInt = 2
        Fixed32 = 3
        Fixed64 = 4
        Bytes = 5
        String = 6
        Submessage = 7
        Extension = 8
        FixedLengthBytes = 9

    TYPE_SHIFT = 0
    TYPE_MASK = 0x0f

    class Attribute(enum.IntEnum):
        required = 0
        optional = 1
        repeated = 2
        oneof = 3

    ATTR_SHIFT = 4
    ATTR_MASK = 0x3

    class Allocation(enum.IntEnum):
        static = 0
        callback = 1
        pointer = 2

    ALLOC_SHIFT = 6
    ALLOC_MASK = 0x3

    def __init__(self, dio, ref_base):
        data = dio.read(self.SIZE)
        if len(data) != self.SIZE:
            raise EOFError('Unexpected EOF')

        if data == self.ZERO:
            self.tag = 0
            self.type = 0
            self.alloc = 0
            self.attr = 0
            self.data_offset = 0
            self.data_size = 0
            self.size_offset = 0
            self.array_size = 0
            self.ptr_or_def = None

            return

        tag, typ_attr_alloc, doff, szoff, dsz, arsz, ptr = self._FMT.unpack(data)

        alloc = self.Allocation((typ_attr_alloc >> self.ALLOC_SHIFT) & self.ALLOC_MASK)
        attr = self.Attribute((typ_attr_alloc >> self.ATTR_SHIFT) & self.ATTR_MASK)
        typ = self.Type((typ_attr_alloc >> self.TYPE_SHIFT) & self.TYPE_MASK)

        if typ == self.Type.Submessage:
            if ptr == 0:
                raise ValueError('Expected a pointer for submessage')
        if ptr != 0:
            if typ in (self.Type.Bytes, self.Type.String, self.Type.FixedLengthBytes) and alloc != self.Allocation.static:
                raise ValueError(
                    'Unexpected pointer field for bytes/string without static allocation (type={}, alloc={})'.format(
                        typ.name, alloc.name))
            if ptr < ref_base:
                raise ValueError('ptr pointing before ref base ({:08x} < {:08x})'.format(ptr, ref_base))
            ptr -= ref_base

        if szoff != 0:
            if ((attr == self.Attribute.oneof) or
                (attr == self.Attribute.optional and alloc == self.Allocation.static) or
                (attr == self.Attribute.repeated and alloc in (self.Allocation.static, self.Allocation.pointer))):
                if szoff > 0:
                    raise ValueError('Size offset must be negative, found {}'.format(szoff))
            else:
                raise ValueError('Found size offset for a field that is not optional or repeated')

        if arsz != 0 and attr != self.Attribute.repeated and alloc != self.Allocation.static:
            raise ValueError('Found array size for a field that is not repeated static')

        if alloc == self.Allocation.callback:
            if attr == self.Attribute.oneof:
                raise ValueError('Found OneOf with callback allocation')

            if dsz != 8:
                raise ValueError('Callback with invalid size = {}'.format(dsz))
        # elif typ == self.Type.Bool:
        #     if dsz == 0 or dsz > 4:
        #         raise ValueError('Bool with invalid size = {}'.format(dsz))
        elif typ in (self.Type.VarInt, self.Type.UVarInt, self.Type.SVarInt):
            if dsz == 0 or dsz > 8:
                raise ValueError('Int with invalid size = {}'.format(dsz))
        elif typ == self.Type.Fixed32:
            if dsz != 4:
                raise ValueError('Fixed32 with invalid size = {}'.format(dsz))
        elif typ == self.Type.Fixed64:
            if dsz != 8:
                raise ValueError('Fixed64 with invalid size = {}'.format(dsz))
        elif typ in (self.Type.String, self.Type.Bytes, self.Type.FixedLengthBytes):
            if dsz == 0:
                raise ValueError('Invalid {} with size 0'.format(typ.name))
            if (alloc == self.Allocation.callback or attr not in (self.Attribute.repeated, self.Attribute.oneof)) and szoff != 0:
                raise ValueError('Invalid {} with size offset {}'.format(typ.name, szoff))

        # Default values are only decoded by nanopb for static allocations, so
        # ignore the pointer if that's not the case and if this isn't a submessage
        # or extension
        if typ not in (self.Type.Submessage, self.Type.Extension) and alloc != self.Allocation.static:
            ptr = None

        self.tag = tag
        self.type = typ
        self.alloc = alloc
        self.attr = attr
        self.data_offset = doff
        self.data_size = dsz
        self.size_offset = szoff
        self.array_size = arsz
        self.ptr_or_def = ptr or None

    def empty(self):
        return (
            self.tag == 0 and self.type == 0 and self.alloc == 0 and
            self.attr == 0 and self.data_offset == 0 and self.data_size == 0 and
            self.size_offset == 0 and self.array_size == 0 and not self.ptr_or_def)

    def __repr__(self):
        return '{}(tag={}, type={}, alloc={}, attr={}, data_offset={}, data_size={}, size_offset={}, array_size={}, ptr={})'.format(
            type(self).__name__, self.tag, self.type.name, self.alloc.name,
            self.attr.name, self.data_offset, self.data_size, self.size_offset,
            self.array_size, self.ptr_or_def)


def decode_default_value(dio, field):
    INT_SIZES_FMT_MAP = {
        1: '<B', 2: '<H', 4: '<I', 8: '<Q',
    }
    TYPE_DECODER_MAP = {
        NanoDesc.Type.VarInt: lambda ds, s: struct.unpack(INT_SIZES_FMT_MAP[ds].lower(), s)[0],
        NanoDesc.Type.UVarInt: lambda ds, s: struct.unpack(INT_SIZES_FMT_MAP[ds].upper(), s)[0],
        NanoDesc.Type.SVarInt: lambda ds, s: struct.unpack(INT_SIZES_FMT_MAP[ds].lower(), s)[0],
        # The following two might actually be signed, or even floating point,
        # but alas we have no way of telling
        NanoDesc.Type.Fixed32: lambda ds, s: struct.unpack(INT_SIZES_FMT_MAP[ds].upper(), s)[0],
        NanoDesc.Type.Fixed64: lambda ds, s: struct.unpack(INT_SIZES_FMT_MAP[ds].upper(), s)[0],
        # Bytes have a size field tucked in front of them
        NanoDesc.Type.Bytes: lambda ds, s: s[4:],
        # Fixed length bytes aren't encoded in any special way
        NanoDesc.Type.FixedLengthBytes: lambda ds, s: s,
        # Strings are UTF-8 encoded
        NanoDesc.Type.String: lambda ds, s: s.rstrip(b'\x00').decode('utf-8'),
    }
    data = dio.read(field.data_size)
    return TYPE_DECODER_MAP[field.type](field.data_size, data)


def unpack_desc(dio, ref_base, desc):
    start = dio.tell()
    try:
        pack = NanoDesc(dio, ref_base)
    except ValueError as e:
        return start + 4
    if pack.empty():
        fields = []
    else:
        fields = [pack]
        while True:
            try:
                pack = NanoDesc(dio, ref_base)
            except ValueError as e:
                return start + 4
            if pack.empty():
                break
            if pack.tag < fields[-1].tag + 1:
                return start + 4
            fields.append(pack)

        for field in fields:
            if field.type == NanoDesc.Type.Submessage:
                sub = desc.get(field.ptr_or_def)
                if not sub:
                    dio.seek(field.ptr_or_def, os.SEEK_SET)
                    s = unpack_desc(dio, ref_base, desc)
                    try:
                        sub = desc[field.ptr_or_def]
                    except KeyError:
                        return start + 4
            elif field.type == NanoDesc.Type.Extension:
                raise NotImplementedError('Extension decoding is not supported')
            elif field.ptr_or_def:
                dio.seek(field.ptr_or_def, os.SEEK_SET)
                field.ptr_or_def = decode_default_value(dio, field)
    desc[start] = fields
    return start + ((len(fields) + 1) * NanoDesc.SIZE)


def read_descriptors(dio, ref_base):
    desc = {}
    DESCRIPTROR_START = b'\x01\x00\x00\x00'

    CHUNK_SIZE = 4 * 1024 * 1024

    offset = 0
    for chunk in iter(lambda: dio.read(CHUNK_SIZE), b''):
        start = 0
        while start < CHUNK_SIZE:
            start = chunk.find(DESCRIPTROR_START, start)
            if start < 0:
                start = CHUNK_SIZE - (len(DESCRIPTROR_START) - 1)
                break
            d = desc.get(offset + start)
            if d:
                start += (len(d) + 1) * NanoDesc.SIZE
            else:
                dio.seek(offset + start, os.SEEK_SET)
                start = unpack_desc(dio, ref_base, desc)
        offset += start
        dio.seek(offset, os.SEEK_SET)

    return desc


def dump_nanopb_descriptors(desc):
    NANO_TO_PROTO_TYPES = {
        NanoDesc.Type.VarInt: lambda f: ('int64' if f.data_size == 8 else 'bool' if field.data_size == 1 else 'int32', ' // enum?'),
        NanoDesc.Type.UVarInt: lambda f: ('uint64' if f.data_size == 8 else 'uint32', ' // enum?'),
        NanoDesc.Type.SVarInt: lambda f: ('sint64' if f.data_size == 8 else 'sint32', ''),
        NanoDesc.Type.Fixed32: lambda f: ('fixed32', ' // sfixed32? float?'),
        NanoDesc.Type.Fixed64: lambda f: ('fixed64', ' // sfixed64? double?'),
        NanoDesc.Type.Bytes: lambda f: ('bytes', ''),
        NanoDesc.Type.String: lambda f: ('string', ''),
        NanoDesc.Type.Submessage: lambda f: ('m{:x}'.format(f.ptr_or_def), ''),
        NanoDesc.Type.FixedLengthBytes: lambda f: ('bytes', ''),
    }
    NANO_TO_PROTO_ATTR = {
        NanoDesc.Attribute.required: 'required ',
        NanoDesc.Attribute.optional: 'optional ',
        NanoDesc.Attribute.repeated: 'repeated ',
        NanoDesc.Attribute.oneof: '',
    }
    print('// Automatically discovered protobuf descriptors ({} messages)\n'.format(len(desc)))
    print('syntax = "proto2";')
    for off, fields in sorted(desc.items()):
        print('\nmessage m{:x} {{'.format(off))
        lines = []
        one_of_indent = ''
        expected_field_tag = 1
        for field in fields:
            while expected_field_tag < field.tag:
                print('    {}reserved {};'.format(one_of_indent, expected_field_tag))
                expected_field_tag += 1

            if one_of_indent:
                if field.attr != NanoDesc.Attribute.oneof or field.data_offset != 0xffffffff:
                    print('    }')
                    one_of_indent = ''

            if field.attr == NanoDesc.Attribute.oneof:
                if field.data_offset == 0xffffffff:
                    if not one_of_indent:
                        raise ValueError('OneOf continuation when not inside oneof')
                elif not one_of_indent:
                    print('    oneof oneof{} {{'.format(field.tag))
                    one_of_indent = '    '

            tp, comment = NANO_TO_PROTO_TYPES[field.type](field)
            opts = []
            can_be_static = False
            if field.attr == NanoDesc.Attribute.repeated:
                if field.type not in (NanoDesc.Type.Bytes, NanoDesc.Type.String, NanoDesc.Type.Submessage, NanoDesc.Type.FixedLengthBytes):
                    opts.append('packed = true')
                if field.array_size > 0:
                    can_be_static = True
                    opts.append('(nanopb).max_count = {}'.format(field.array_size))
                    if field.size_offset == 0:
                        opts.append('(nanopb).fixed_count = true')
            elif field.type != NanoDesc.Type.Submessage and field.ptr_or_def is not None:
                opts.append('default = {}'.format(field.ptr_or_def))

            if field.alloc != NanoDesc.Allocation.static:
                opts.append('(nanopb).type = FT_{}'.format(field.alloc.name.upper()))

            if field.type in (NanoDesc.Type.VarInt, NanoDesc.Type.UVarInt, NanoDesc.Type.SVarInt):
                if tp != 'bool' and int(tp[-2:]) // 8 != field.data_size:
                    opts.append('(nanopb).int_size = {}'.format(field.data_size))
            elif field.type in (NanoDesc.Type.FixedLengthBytes, NanoDesc.Type.String):
                opts.append('(nanopb).max_size = {}'.format(field.data_size))
                if field.type == NanoDesc.Type.FixedLengthBytes:
                    opts.append('(nanopb).fixed_length = true')
            elif field.type == NanoDesc.Type.Bytes:
                opts.append('(nanopb).max_size = {}'.format(field.data_size - 4))
            if opts:
                opts = ' [{}]'.format(', '.join(opts))
            else:
                opts = ''
            print('    {}{}{} f{} = {}{};{}'.format(one_of_indent, NANO_TO_PROTO_ATTR[field.attr], tp, field.tag, field.tag, opts, comment))
            expected_field_tag += 1
        if one_of_indent:
            print('    }')
        print('}')


if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument('binary', type=argparse.FileType('rb'), help='Path to the extracted MAIN part from the modem firmware')
    parser.add_argument('-l', '--load_address', type=lambda s: int(s, 16), required=True, help='The load address of MAIN')
    args = parser.parse_args()

    desc = read_descriptors(args.binary, args.load_address)
    dump_nanopb_descriptors(desc)
